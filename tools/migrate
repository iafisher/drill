#!/usr/bin/env python3
"""
Use this script to migrate quizzes from the old JSON format of version 1 to the textual
format of version 2.

It will also update results files.

Author:  Ian Fisher (iafisher@protonmail.com)
Version: October 2019
"""
import argparse
import json
import os
import re
import subprocess
import sys
from collections import OrderedDict


def main():
    if len(sys.argv) > 1:
        sys.stderr.write("Error: migrate accepts no command-line arguments.\n")
        sys.exit(1)

    paths = get_all_paths()
    if not paths:
        sys.stderr.write("Error: no quizzes found.\n")
        sys.exit(2)

    count = 0
    for path in paths:
        shortname = os.path.split(path)[1]
        if not ask("Do you want to migrate '{}'? ".format(shortname)):
            continue

        with open(path, "r", encoding="utf-8") as f:
            quiz = json.load(f, object_hook=OrderedDict)

        new_path = os.path.splitext(path)[0]
        with open(new_path, "w", encoding="utf-8") as writer:
            text_to_id = migrate(quiz, writer)

        result_path = get_results_path(path)
        if os.path.exists(result_path):
            with open(result_path, "r", encoding="utf-8") as f:
                results = json.load(f)

            with open(result_path, "w", encoding="utf-8") as writer:
                migrate_results(text_to_id, results, writer)

        count += 1
        print("Successfully migrated '{}'.\n".format(shortname))

    print("Successfully migrated {} file(s).".format(count))


def migrate(quiz, writer):
    default_kind = quiz.get("default_kind", "ShortAnswer")
    text_to_id = {}
    for i, question in enumerate(quiz["questions"]):
        writer.write("[{}] ".format(i+1))
        kind = question.get("kind", default_kind)
        if "text" in question:
            if isinstance(question["text"], str):
                writer.write(question["text"])
                text_to_id[question["text"]] = i+1
            else:
                writer.write(question["text"][0])
                text_to_id[question["text"][0]] = i+1
            writer.write("\n")
        elif kind != "Flashcard":
            raise RuntimeError("question missing `text` field")
        else:
            text_to_id[question["side1"]] = i+1

        if kind == "ShortAnswer":
            write_answer(question["answer"], writer)
        elif kind == "ListAnswer" or kind == "OrderedListAnswer":
            for answer in question["answer_list"]:
                write_answer(answer, writer)
            if kind == "OrderedListAnswer":
                writer.write("- ordered: true\n")
        elif kind == "MultipleChoice":
            write_answer(question["answer"], writer)
            writer.write("- choices: ")
            write_answer(question["candidates"], writer)
        elif kind == "Ungraded":
            raise RuntimeError("Ungraded questions are no longer supported")
        elif kind == "Flashcard":
            writer.write(question["side1"])
            writer.write(" = ")
            write_answer(question["side2"], writer)
        else:
            raise RuntimeError("unknown kind: " + kind)

        if "tags" in question:
            writer.write("- tags: ")
            writer.write(", ".join(question["tags"]))
            writer.write("\n")

        writer.write("\n")

    return text_to_id


def migrate_results(text_to_id, results, writer):
    new_results = {}
    for text, results in results.items():
        if text in text_to_id:
            id_ = text_to_id[text]
            new_results[id_] = results

    json.dump(new_results, writer, indent=2, ensure_ascii=False)


def write_answer(answer, writer):
    if isinstance(answer, str):
        writer.write(answer)
    else:
        writer.write(" / ".join(answer))
    writer.write("\n")


def get_all_paths():
    env = os.environ.copy()
    env["NO_COLOR"] = "yes"
    proc = subprocess.run(
        ["quiz", "path", "-f", "whatever"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        env=env,
    )
    output = proc.stdout.strip().decode("utf-8")
    if output.startswith(("Error", "error")):
        return []
    else:
        dirpath = os.path.split(output)[0]
        return [
            os.path.join(dirpath, entry)
            for entry in os.listdir(dirpath)
            if entry != ".gitignore" and entry != ".git"
        ]


def get_results_path(quiz_path):
    quiz_dir, path = os.path.split(quiz_path)
    app_dir = os.path.split(quiz_dir)[0]
    stem, ext = os.path.splitext(path)
    return os.path.join(app_dir, "results", stem + "_results" + ext)


def ask(prompt):
    while True:
        answer = input(prompt).strip().lower()
        if answer.startswith("y"):
            return True
        elif answer.startswith("n"):
            return False


if __name__ == "__main__":
    main()
